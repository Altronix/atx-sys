#include "network_management.h"
#include <sys/stat.h>

#define HEADER                                                                 \
    "# This file is generated by altronix atx-sys program.\n"                  \
    "# This file will be overwritten on startup.\n"                            \
    "# To configure the network please consult atx-sys.\n\n"

#define COMMON                                                                 \
    "auto lo\n"                                                                \
    "iface lo inet loopback\n\n"                                               \
    "iface eth0 inet static\n"                                                 \
    "  address 127.0.0.1\n"                                                    \
    "  netmask 255.255.255.0\n\n"

#define STATIC                                                                 \
    "iface eth0.10 inet static\n"                                              \
    "  address %.*s\n"                                                         \
    "  netmask %.*s\n"                                                         \
    "  gateway %.*s\n"                                                         \
    "  pre-up /etc/network/nfs_check\n"                                        \
    "  wait-delay 15\n"                                                        \
    "  hostname %.*s\n\n"

#define DHCP                                                                   \
    "iface eth0.10 inet dhcp\n"                                                \
    "  pre-up /etc/network/nfs_check\n"                                        \
    "  wait-delay 15\n"                                                        \
    "  hostname %.*s\n\n"

#define DEVICE_LAN                                                             \
    "iface eth0.20 inet static\n"                                              \
    "  address 192.168.168.100\n"                                              \
    "  netmask 255.255.255.0\n"

#define NETWORK_MANAGEMENT_JSON_FORMAT                                         \
    "{"                                                                        \
    "\"ipv4\":"                                                                \
    "{"                                                                        \
    "\"meth\":\"%.*s\","                                                       \
    "\"hn\":\"%.*s\","                                                         \
    "\"ip\":\"%.*s\","                                                         \
    "\"sn\":\"%.*s\","                                                         \
    "\"gw\":\"%.*s\""                                                          \
    "}"                                                                        \
    "}"

typedef struct tag_s
{
    jsmn_value** value;
    const char* key;
} tag_s;

int
print_network_interface(
    FILE* f,
    jsmn_value* meth,
    jsmn_value* ip,
    jsmn_value* sn,
    jsmn_value* gw,
    jsmn_value* hn)
{
    int err;
    if (!strncmp(meth->p, "DHCP", meth->len) ||
        !strncmp(meth->p, "dhcp", meth->len) ||
        !strncmp(meth->p, "Dhcp", meth->len)) {
        err = fprintf(f, HEADER COMMON DHCP DEVICE_LAN, hn->len, hn->p);
    } else {
        // clang-format off
        err = fprintf(
            f,
            HEADER COMMON STATIC DEVICE_LAN,
            ip->len, ip->p,
            sn->len, sn->p,
            gw->len, gw->p,
            hn->len, hn->p);
        // clang-format on
    }
    return err;
}

int
parse_network_config(
    const char* buff,
    uint32_t len,
    jsmn_value* meth,
    jsmn_value* ip,
    jsmn_value* sn,
    jsmn_value* gw,
    jsmn_value* hn)
{
    tag_s tags[] = { { .key = ".ipv4.ip", .value = &ip },
                     { .key = ".ipv4.sn", .value = &sn },
                     { .key = ".ipv4.gw", .value = &gw },
                     { .key = ".ipv4.meth", .value = &meth },
                     { .key = ".ipv4.hn", .value = &hn } };
    int err, i, n = sizeof(tags) / sizeof(tag_s);
    struct stat st;
    jsmn_parser p;
    jsmntok_t toks[128];
    const jsmntok_t* t;

    // Parse contents
    jsmn_init(&p);
    err = jsmn_parse(&p, buff, len, toks, 128);
    if (err <= 0) { return -1; }

    for (i = 0; i < n; i++) {
        t = json_delve(buff, toks, tags[i].key);
        if (!t) break;
        (*tags[i].value)->p = &buff[t->start];
        (*tags[i].value)->len = t->end - t->start;
    }

    return i == n ? 0 : -1;
}

int
print_network_config(
    FILE* f,
    jsmn_value* meth,
    jsmn_value* ip,
    jsmn_value* sn,
    jsmn_value* gw,
    jsmn_value* hn)
{
    // clang-format off
    return fprintf(
        f,
        NETWORK_MANAGEMENT_JSON_FORMAT,
        meth->len, meth->p,
        hn->len,   hn->p,
        ip->len,   ip->p,
        sn->len,   sn->p,
        gw->len,   gw->p
        );
    // clang-format on
}

int
print_network_config_toks(
    FILE* f,
    const char* b,
    const jsmntok_t* tmeth,
    const jsmntok_t* tip,
    const jsmntok_t* tsn,
    const jsmntok_t* tgw,
    const jsmntok_t* thn)
{
    jsmn_value meth, ip, sn, gw, hn;
    meth = json_tok_value(b, tmeth);
    ip = json_tok_value(b, tip);
    sn = json_tok_value(b, tsn);
    gw = json_tok_value(b, tgw);
    hn = json_tok_value(b, thn);
    return print_network_config(f, &meth, &ip, &sn, &gw, &hn);
}
